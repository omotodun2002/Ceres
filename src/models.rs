use chrono::{DateTime, Utc};
use pgvector::Vector;
use serde::{Deserialize, Serialize};
use sqlx::prelude::FromRow;
use sqlx::types::Json;
use uuid::Uuid;

/// Complete representation of a row from the 'datasets' table.
///
/// This structure represents a persisted dataset with all database fields,
/// including system-generated identifiers and timestamps. It maps directly
/// to the PostgreSQL schema and is used for reading data from the database.
///
/// # Fields
///
/// * `id` - Unique identifier (UUID) generated by the database
/// * `original_id` - Original identifier from the source portal
/// * `source_portal` - Base URL of the originating CKAN portal
/// * `url` - Public landing page URL for the dataset
/// * `title` - Human-readable dataset title
/// * `description` - Optional detailed description
/// * `embedding` - Optional 1536-dimensional vector for semantic search
/// * `metadata` - Additional metadata stored as JSONB
/// * `first_seen_at` - Timestamp when the dataset was first indexed
/// * `last_updated_at` - Timestamp of the most recent update
///
/// # Examples
///
/// ```no_run
/// use ceres::storage::DatasetRepository;
/// use uuid::Uuid;
/// # use sqlx::PgPool;
///
/// # async fn example(repo: DatasetRepository) -> Result<(), Box<dyn std::error::Error>> {
/// let id = Uuid::parse_str("550e8400-e29b-41d4-a716-446655440000")?;
/// if let Some(dataset) = repo.get(id).await? {
///     println!("Title: {}", dataset.title);
///     println!("Portal: {}", dataset.source_portal);
///     if let Some(embedding) = dataset.embedding {
///         println!("Embedding dimension: {}", embedding.as_slice().len());
///     }
/// }
/// # Ok(())
/// # }
/// ```
#[derive(Debug, FromRow, Serialize)]
pub struct Dataset {
    /// Unique identifier (UUID) generated by the database
    pub id: Uuid,
    /// Original identifier from the source portal
    pub original_id: String,
    /// Base URL of the originating CKAN portal
    pub source_portal: String,
    /// Public landing page URL for the dataset
    pub url: String,
    /// Human-readable dataset title
    pub title: String,
    /// Optional detailed description
    pub description: Option<String>,

    /// Optional 1536-dimensional vector for semantic search (pgvector type)
    pub embedding: Option<Vector>,

    /// Additional metadata stored as JSONB
    pub metadata: Json<serde_json::Value>,

    /// Timestamp when the dataset was first indexed
    pub first_seen_at: DateTime<Utc>,
    /// Timestamp of the most recent update
    pub last_updated_at: DateTime<Utc>,
}

/// Data Transfer Object for inserting or updating datasets.
///
/// This structure is used when creating new datasets or updating existing ones.
/// Unlike `Dataset`, it doesn't include database-generated fields like `id` or
/// timestamps. The embedding field uses `Vec<f32>` instead of pgvector's `Vector`
/// for easier manipulation before database storage.
///
/// # Fields
///
/// * `original_id` - Original identifier from the source portal
/// * `source_portal` - Base URL of the originating CKAN portal
/// * `url` - Public landing page URL for the dataset
/// * `title` - Human-readable dataset title
/// * `description` - Optional detailed description
/// * `embedding` - Optional vector of 1536 floats (converted to pgvector on storage)
/// * `metadata` - Additional metadata as JSON
///
/// # Examples
///
/// ```no_run
/// use ceres::models::NewDataset;
/// use ceres::storage::DatasetRepository;
/// # use sqlx::PgPool;
///
/// # async fn example(repo: DatasetRepository) -> Result<(), Box<dyn std::error::Error>> {
/// let new_dataset = NewDataset {
///     original_id: "dataset-123".to_string(),
///     source_portal: "https://dati.gov.it".to_string(),
///     url: "https://dati.gov.it/dataset/my-dataset".to_string(),
///     title: "My Dataset".to_string(),
///     description: Some("A comprehensive dataset".to_string()),
///     embedding: None, // Will be populated after generating embeddings
///     metadata: serde_json::json!({
///         "organization": "Ministry of Data",
///         "tags": ["opendata", "government"]
///     }),
/// };
///
/// let uuid = repo.upsert(&new_dataset).await?;
/// println!("Dataset saved with ID: {}", uuid);
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Serialize, Clone)]
pub struct NewDataset {
    /// Original identifier from the source portal
    pub original_id: String,
    /// Base URL of the originating CKAN portal
    pub source_portal: String,
    /// Public landing page URL for the dataset
    pub url: String,
    /// Human-readable dataset title
    pub title: String,
    /// Optional detailed description
    pub description: Option<String>,
    /// Optional vector of 1536 floats (converted to pgvector on storage)
    pub embedding: Option<Vector>,
    /// Additional metadata as JSON
    pub metadata: serde_json::Value,
}

/// Risultato di una ricerca semantica con score di similarità
///
/// Questa struttura combina un dataset con il suo score di similarità rispetto
/// alla query di ricerca. Lo score rappresenta la cosine similarity tra l'embedding
/// del dataset e l'embedding della query, con valori tra 0.0 (nessuna similarità)
/// e 1.0 (identici).
///
/// # Examples
///
/// ```no_run
/// use ceres::models::SearchResult;
/// use ceres::storage::DatasetRepository;
/// use pgvector::Vector;
/// # use sqlx::PgPool;
///
/// # async fn example(repo: DatasetRepository) -> Result<(), Box<dyn std::error::Error>> {
/// let query_vector = Vector::from(vec![0.1; 1536]);
/// let results = repo.search(query_vector, 10).await?;
///
/// for result in results {
///     println!("[{:.2}] {}", result.similarity_score, result.dataset.title);
/// }
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Serialize, Clone)]
pub struct SearchResult {
    /// Il dataset trovato
    pub dataset: Dataset,
    /// Score di similarità (0.0-1.0), dove 1.0 è match perfetto
    pub similarity_score: f32,
}

/// Statistiche del database per la dashboard
///
/// Fornisce una panoramica dello stato del database, utile per dashboard
/// e monitoring.
///
/// # Examples
///
/// ```no_run
/// use ceres::storage::DatasetRepository;
/// # use sqlx::PgPool;
///
/// # async fn example(repo: DatasetRepository) -> Result<(), Box<dyn std::error::Error>> {
/// let stats = repo.get_stats().await?;
/// println!("Total datasets: {}", stats.total_datasets);
/// println!("With embeddings: {}", stats.datasets_with_embeddings);
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Serialize, Clone)]
pub struct DatabaseStats {
    /// Numero totale di dataset nel database
    pub total_datasets: i64,
    /// Numero di dataset con embeddings generati
    pub datasets_with_embeddings: i64,
    /// Numero di portali unici indicizzati
    pub total_portals: i64,
    /// Timestamp dell'ultimo update
    pub last_update: Option<DateTime<Utc>>,
}

/// Portale configurato in portals.toml
///
/// Rappresenta un portale open data configurato per l'harvesting.
/// Supporta diversi tipi di portali (CKAN, Socrata, DCAT).
///
/// # Examples
///
/// ```
/// use ceres::models::Portal;
///
/// let portal = Portal {
///     name: "Milano Open Data".to_string(),
///     url: "https://dati.comune.milano.it".to_string(),
///     portal_type: "ckan".to_string(),
///     enabled: true,
///     description: Some("Portale del Comune di Milano".to_string()),
/// };
///
/// assert_eq!(portal.portal_type, "ckan");
/// assert!(portal.enabled);
/// ```
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Portal {
    /// Nome del portale (human-readable)
    pub name: String,
    /// URL base del portale
    pub url: String,
    /// Tipo di portale ("ckan", "socrata", "dcat")
    #[serde(rename = "type")]
    pub portal_type: String,
    /// Se il portale è abilitato per l'harvesting
    #[serde(default = "default_enabled")]
    pub enabled: bool,
    /// Descrizione opzionale del portale
    pub description: Option<String>,
}

/// Default value for Portal.enabled field
fn default_enabled() -> bool {
    true
}
